% SAL model of OM(1)
%
% Oral Messages 1 algorithm
% version 5
%
% Notes:
%   * parametrized number of relays 'n' and receivers 'k'
%   * communication is modeled through a REAL time clock module and a
%     calendar automata that keeps track of messages and delivery times
%   * attempted to minimize number of state vars
%   * all nodes in 'system' are composed asynchronously
%   * main properties are specified using synchronous observer 'observer'
%   * hybrid fault model is implemented through the message-read mechanism
%     and constraints at the LTL level
%
% Authors: Benjamin F Jones <bjones@galois.com>, Galois Inc. (2016)
%          Lee Pike                            , Galois Inc. (2016)
%
% References:
%
% [1] R. Boyer and J. Moore. MJRTY - A Fast Majority Vote Algorithm. SRI
%     Technical Report 32. February 1981.
%
% [2] J. Rushby. SAL Tutorial: Analyzing the Fault-Tolerant Algorithm OM(1).
%     CSL Technical Note, April 2004.
%
% [OMH] P. Lincoln and J. Rushby. A Formally Verified Algorithm for
%       Interactive Consistency Under a Hybrid Fault Model.
%       Proceedings of the Fault-Tolerant Computing Symposium, FTCS 23,
%       Toulouse, France, June 1993, pp. 402â€“411.
%       http://www.csl.sri.com/users/rushby/papers/ftcs93.pdf
%



%
% Parameters:
%
% num_relays = # of relays
% num_recvs  = # of receivers
%
om1_tt {; num_relays: nznat, num_recvs: nznat}: CONTEXT =
BEGIN

%=== Basic Types -------------------------------------------------===

% IDs for nodes
num_nodes:    NATURAL = num_relays + num_recvs + 1;
IDENTITY:     TYPE = [0..(num_nodes-1)];
IDX :         TYPE = [0..(num_relays+1)];
RELAYS:       TYPE = [1..num_relays];
RELAYS_COUNT: TYPE = [0..num_relays];

% UNCOMMENT the following lines to get an INFINITE model.
%
TIME: TYPE = { t: REAL | t >= -2 };
MESSAGE: TYPE = { m: INTEGER | m >= -1 };
REAL_MESSAGE: TYPE = { m: MESSAGE | m >= 0 };
uninterp_msg(i: IDENTITY, j: IDENTITY): REAL_MESSAGE;

% UNCOMMENT the following lines to get a FINITE model.
%
% This is mostly for debugging purposes, e.g. running 'sal-deadlock-checker'
% and 'sal-path-finder' over the model.
%
% upper_bound : INTEGER = 10;  % needs to be larger than largest special msg value
% TIME: TYPE = [-2..upper_bound];
% MESSAGE: TYPE = [-1..upper_bound];
% uninterp_msg(i: IDENTITY, j: IDENTITY): INTEGER = upper_bound;


%=== Nodes and IDs -----------------------------------------------===


% Relay IDs
source_id: IDENTITY = 0;
relay_id(n: nznat): RELAYS = n;  % map relay # to relay ID
id_relay(i: RELAYS): nznat = i;  % invert ^^^

% Receiver IDs
RECEIVERS: TYPE = [(num_relays+1)..(num_relays+num_recvs)];
receiver_id(k: nznat): RECEIVERS = num_relays + k;  % map receiver # to ID
id_receiver(i: RECEIVERS): nznat = i - num_relays;  % invert ^^^

% Helper functions for identification
is_source?(i: IDENTITY):   BOOLEAN = i = source_id;
is_relay?(i: IDENTITY):    BOOLEAN = 1 <= i AND i <= num_relays;
is_receiver?(i: IDENTITY): BOOLEAN = num_relays+1 <= i;


%=== Channels ----------------------------------------------------===

% We allocate one channel (ID) for each physical channel in the system,
% plus one for each "self-channel" that each receiver uses to execute in
% an atomic block (see the 'receiver' MODULEs below).
%
% let n = num_relays
%     k = num_recvs
%
% channel IDs
%
%   1            - n          : source -> n relays
%   (n+1)        - (n+k)      : relay 1 -> k receivers  : relay i -> recv j is
%   (n+1+k)      - (n+2k)     : relay 2 -> k receivers  : n+(i-1)k+j
%    .              .         :  .
%   (n+1+(n-1)k) - (n+nk)     : relay n -> k receivers
%   (n+1+nk)     - (n+(n+1)k) : receiver -> self
%
num_channels : nznat = num_relays + (num_relays+1)*num_recvs;
CHANNEL: TYPE = [1..num_channels];

% Determine if there is a channel from node ID i -> j. This is fixed at
% compile time based on the topology of the system.
linked?(i:IDENTITY, j:IDENTITY): BOOLEAN =
     (i = 0           AND is_relay?(j))
  OR (is_relay?(i)    AND is_receiver?(j))
  OR (is_receiver?(i) AND i = j);

% Compute channel ID from the (src, dest) pair
%
% precondition: linked?(i,j) == True
chan(i:IDENTITY, j:IDENTITY): CHANNEL =
  IF is_source?(i) THEN  % source -> relay chans are 1, 2, ... num_relays
    j
  ELSIF is_relay?(i) THEN
    num_relays + (id_relay(i) - 1)*num_recvs + id_receiver(j)
  ELSE  % i = j is a receiver
    id_receiver(i) + num_relays*(num_recvs + 1)
  ENDIF;

% Is the channel attached on either end to a receiver
is_receiver_channel?(c: CHANNEL): BOOLEAN =
  c > num_relays;

%=== Time --------------------------------------------------------===

% Time is modeled by real numbers, where
%
%   -1 is reserved as an invalid time
%   -2 is reserved as an atomic "out-of-band" time
%
% Times which appear as event times on the calendar are restriced to the set
% {-2} U {-1} U { t >= 0 }.
%
invalid_time: TIME = -1;
atomic_time:  TIME = -2;
msg_delay:    TIME = 1;


%=== Faults ------------------------------------------------------===

% For details on the hybrid fault model, see [2].
FAULT_TYPE: TYPE = { nonfaulty, byzantine, manifest, symmetric };
FAULTS: TYPE = ARRAY IDENTITY OF FAULT_TYPE;
is_faulty?(fi: FAULT_TYPE): BOOLEAN = fi /= nonfaulty;

% A "faulty" message is a real message that is not the 'good_msg' value. A
% "real" message is one that is not 'missing'.
is_faulty_msg?(m: MESSAGE): BOOLEAN = m > 0;

%=== Messages and Values -----------------------------------------===

% values recieved by relays and receivers
%
% MESSAGE is modeled as an uninterpreted type (represented by INTEGER)
% to support nodes emitting an arbitrary number of distinct faulty (non-good)
% values

% some named messages
good_msg:    MESSAGE = 0;   % when 'source' is not faulty, this is the
                            %   intended message
bad_msg:      MESSAGE = 1;  % used for manifest faults
recv_bad_msg: MESSAGE = 2;  % indicates that the sender itself received a
                            %   manifestly bad message
error_vote:   MESSAGE = 3;  % indicates an error in the voting, e.g. if no
                            %   non- bad messages were received
missing:     MESSAGE = -1;  % used as a placeholder initial value

% Change a 'bad_msg' into the special value 'recv_bad_msg' before it is stored
% in a latch or a buffer.
wrap(m: MESSAGE): MESSAGE = IF m = bad_msg OR m = missing
                                   THEN recv_bad_msg
                                   ELSE m ENDIF;

unwrap(m: MESSAGE): MESSAGE = IF m = recv_bad_msg THEN bad_msg ELSE m ENDIF;

% Check is a message value has been stored and is not the special missing
% value.
is_wrapped?(m: MESSAGE): BOOLEAN = m /= missing AND m /= bad_msg;

% Values produced by reading from the calendar are constrained to be "real"
% messages. Additional constraints are added by the hybrid fault model's maximum
% fault assumption, see 'mfa' in the verification section.
%
% 'uninter_msg' is an uninterpreted function whose values represent unknown
% messages sent between nodes 'i' and 'j'. We make the simplifying assumption
% here that each node 'i' only ever sends one message to node 'j' and thus
% 'uninterp_msg' does not need to depend on time.
%

% Count the number of a certain message in a buffer
cntBuf(ix: RELAYS, max: RELAYS, buffer: ARRAY RELAYS of MESSAGE, m: MESSAGE):
NATURAL =
  IF ix > num_relays OR ix > max
    THEN 0
    ELSIF buffer[ix] = m
      THEN cntBuf(ix+1, max, buffer, m) + 1
      ELSE cntBuf(ix+1, max, buffer, m)
  ENDIF;

% Check if there is a (hybrid) majority in a buffer. A hybrid majority is a
% majority amoung the non-manifestly faulty values (msg /= bad_msg).
% The manifest fault 'bad_msg' is explicitly ruled out.
has_majority?(buf: ARRAY RELAYS OF MESSAGE): BOOLEAN =
  LET d:INTEGER = cntBuf(relay_id(1), relay_id(num_relays), buf, bad_msg) IN
  EXISTS (i:RELAYS):
    buf[i] /= bad_msg AND
    2*cntBuf(relay_id(1), relay_id(num_relays), buf, buf[i]) > num_relays - d;

% Check if a certain value is in the (hybrid) majority in a buffer.
% The manifest fault 'bad_msg' is explicitly ruled out.
m_is_majority(buf: ARRAY RELAYS OF MESSAGE, m: MESSAGE): BOOLEAN =
  LET d:INTEGER = cntBuf(relay_id(1), relay_id(num_relays), buf, bad_msg) IN
  m /= bad_msg AND
  2*cntBuf(relay_id(1), relay_id(num_relays), buf, m) > num_relays - d;


%=== Calendar Automata -------------------------------------------===

% Calendar data structure for communication between nodes. The structure
% allows for at most 1 message to be sent from any node to any other
% at a given time.

CALENDAR: TYPE =
  [# msg  : ARRAY CHANNEL of MESSAGE,  % contents of message
     time : ARRAY CHANNEL of TIME      % time for delivery
  #];

empty_calendar: CALENDAR =
  (# msg  := [[c:CHANNEL] missing],
     time := [[c:CHANNEL] invalid_time]
  #);


%=== Calendar API ------------------------------------------------===


msg(s: TIME, cal: CALENDAR, f: FAULTS, i:IDENTITY, j:IDENTITY): MESSAGE =
  IF f[i] = byzantine OR f[i] = symmetric THEN
    % The symmetric case is further constrained below, see 'mfa'.
    % Note: the case of a source with symmetric fault is equivalent to
    % the non-faulty case.
    uninterp_msg(i, j)
  ELSIF f[i] = manifest THEN
    % manifest case: return a manifestly faulty value
    bad_msg
  ELSE
    % non-faulty (or symmetric source) case: return intended message
    cal.msg[chan(i,j)]
  ENDIF;

% Helper functions for getting/setting the calendar
null?(cal: CALENDAR, c: CHANNEL): BOOLEAN =
  cal.msg[c] = missing AND cal.time[c] = invalid_time;

% Is the given time the minimum among all valid times on the calendar?
is_next_time?(cal:CALENDAR, t:TIME): BOOLEAN =
      (FORALL (c:CHANNEL): NOT null?(cal,c) => t <= cal.time[c])
  AND (EXISTS (c:CHANNEL): NOT null?(cal,c) AND t = cal.time[c]);

delivery(cal: CALENDAR, i:IDENTITY, j:IDENTITY): TIME =
  cal.time[chan(i,j)];

% Is there a regular event i -> j yet to occur at the given time?
% Returns FALSE if
%
%     A) the pair i,j has no channel between them OR
%     B) the current time is 'atomic_time'
%
node_event?(cal:CALENDAR, i:IDENTITY, j:IDENTITY, t:TIME): BOOLEAN =
      linked?(i,j)
  AND is_next_time?(cal,t)
  AND NOT null?(cal,chan(i,j))
  AND delivery(cal,i,j) = t
  AND t /= atomic_time;

% is there an event yet to occur at the given time?
event_pending?(cal:CALENDAR, t:TIME): BOOLEAN =
  (EXISTS (c:CHANNEL): cal.msg[c] /= missing AND cal.time[c] = t);

% Am I in atomic mode?
i_am_atomic?(cal: CALENDAR, i: IDENTITY, t: TIME): BOOLEAN =
      EXISTS (j: IDENTITY): linked?(i,j) AND cal.time[chan(j,i)] = atomic_time
  AND t = atomic_time;

% send a message with given delay
msg_send_delta(cal: CALENDAR, i: IDENTITY, j:IDENTITY, m:MESSAGE, t:TIME, d:TIME):
CALENDAR =
  cal WITH .msg[chan(i,j)]  := m
      WITH .time[chan(i,j)] := t + d;

% default msg_send function has 'msg_delay' delay
msg_send(cal: CALENDAR, i: IDENTITY, j:IDENTITY, m:MESSAGE, t:TIME): CALENDAR =
  msg_send_delta(cal, i, j, m, t, msg_delay);

% add a 'preemtive' message (or interrupt) to the calendar. This action
% prevents transitions from occuring except in the 'atomic' section of the
% calling module.
msg_send_interrupt(cal: CALENDAR, i: IDENTITY, j:IDENTITY): CALENDAR =
  msg_send_delta(cal, i, j, good_msg, atomic_time, 0);

msg_consume(cal: CALENDAR, i: IDENTITY, j:IDENTITY): CALENDAR =
  cal WITH .msg[chan(i,j)]  := missing
      WITH .time[chan(i,j)] := invalid_time;


%===  Message broadcast functions  ===%

% broadcast a message from the source to each relay
msg_source_bcast_aux(cal: CALENDAR, m: MESSAGE, t: TIME, i: nznat, n: nznat):
CALENDAR =
  IF i < n
    THEN LET cal1:CALENDAR = msg_send(cal, source_id, i, m, t)
         IN  msg_source_bcast_aux(cal1, m, t, i+1, n)
    ELSE cal
  ENDIF;

msg_source_bcast(cal: CALENDAR, m: MESSAGE, t: TIME): CALENDAR =
  msg_source_bcast_aux(cal, m, t, relay_id(1), relay_id(1)+num_relays);

% broadcast a message from a relay ID 'i' to each receiver
msg_relay_bcast_aux(cal: CALENDAR, r: RELAYS, m: MESSAGE, t: TIME, i: nznat, n: nznat):
CALENDAR =
  IF i < n
    THEN LET cal1:CALENDAR = msg_send(cal, r, i, m, t)
         IN  msg_relay_bcast_aux(cal1, r, m, t, i+1, n)
    ELSE cal
  ENDIF;

msg_relay_bcast(cal: CALENDAR, r: RELAYS, m: MESSAGE, t: TIME): CALENDAR =
  msg_relay_bcast_aux(cal, r, m, t, receiver_id(1), receiver_id(1)+num_recvs);


%===----------------------------------------------------------------===
%       Transition System
%===----------------------------------------------------------------===

%
% The 'clock' module gives the general its message and manages the
% advance of time.
clock: MODULE =
BEGIN
    GLOBAL
      cal: CALENDAR,
      t:   TIME,
      f:   FAULTS
    INPUT
      receivers_done: ARRAY RECEIVERS OF BOOLEAN
    OUTPUT
      source_done: BOOLEAN,
      relays_done: BOOLEAN
DEFINITION
    source_done = t > 1;
    relays_done = t > 2;
INITIALIZATION
    cal = empty_calendar;
    t = 0;
TRANSITION
    [
      advance_time:
        NOT is_next_time?(cal,t) --> t' IN { s:TIME | is_next_time?(cal,s) }
    []
      % allow clock to stutter once the system reaches the end of one round
      stutter:
            source_done AND relays_done
        AND (FORALL (i:RECEIVERS): receivers_done[i]) --> % nothing
    ]
END;

% 'source' sends a message (good_msg) to all relays
source: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT  t: TIME
TRANSITION
    [
      source_broadcast:
      t = 0 -->
        cal' = msg_source_bcast(cal, good_msg, t);
    ]
END;


relay[i: RELAYS]: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT  f: FAULTS, t: TIME
    OUTPUT
      latch: MESSAGE,
      latched? : BOOLEAN
INITIALIZATION
    latch      = missing;
    latched?   = FALSE;
TRANSITION
    [
      relay_broadcast:
      (1 > t AND t <= 2) AND node_event?(cal, source_id, i, t) -->
        % acknowledge a manifestly bad message by storing and passing on a
        % designated value 'recv_bad_msg'
        latch' = wrap(msg(t, cal, f, source_id, i));
        cal' = LET m:MESSAGE = wrap(msg(t, cal, f, source_id, i)) IN
               LET cal1:CALENDAR = msg_relay_bcast(cal, i, m, t) IN
               msg_consume(cal1, source_id, i);
        latched?' = TRUE;
     []
      (1 > t AND t <= 2) -->
     []
      (t > 2) AND NOT latched? --> latch' = wrap(bad_msg);
    ]
END;

% Receiver modes:
%
%   - 'receiving' message buffer is not yet full
%   - 'voting'    buffer is full; computing majority vote over the buffer
%   - 'done'      voting is complete and 'vote' is set with result
%
RECEIVER_MODES: TYPE = {receiving, voting, done};

receiver[p:RECEIVERS]: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT  f: FAULTS, t: TIME
    OUTPUT
        buffer: ARRAY RELAYS of MESSAGE,
        vote: MESSAGE,
        receiver_done: BOOLEAN,
        counter: RELAYS_COUNT,
        ix: IDX
    LOCAL
        mode: RECEIVER_MODES,
        buffer_size: RELAYS_COUNT,
        candidate: MESSAGE
INITIALIZATION
    % outputs
    mode = receiving;
    receiver_done = FALSE;
    vote = missing;
    % locals
    buffer = [[r:RELAYS] missing];  % init empty buffer
    buffer_size = 0;
    candidate = missing;
    counter = 0;
    ix = 0;  % 0 -> voting hasn't started, i -> examining buffer[i]
TRANSITION
    [
      %----------------------------------------------------------------
      % Receive a message from a relay
      %
      % When 'buffer' is full send a self- message with delivery
      % 'atomic_time'. This acquires the atomic lock so the following
      % transitions are enabled.
      %----------------------------------------------------------------

   ([] (i:RELAYS):
      receiver_recv:
          (2 > t AND t <= 3) AND mode = receiving
      AND node_event?(cal, i, p, t) AND buffer[i] = missing -->
        buffer'[i]   = msg(t, cal, f, i, p);
        buffer_size' = buffer_size + 1;
        cal'         = IF buffer_size' = num_relays  % buffer is full
                          THEN LET cal1: CALENDAR = msg_consume(cal, i, p)
                               IN  msg_send_interrupt(cal1, p, p)
                          ELSE msg_consume(cal, i, p)
                       ENDIF;
        mode'        = IF buffer_size' = num_relays  % buffer is full
                         THEN voting
                         ELSE receiving
                       ENDIF;
      )
    []
      %----------------------------------------------------------------
      % drop incoming message if buffer[i] is full
      %----------------------------------------------------------------

   ([] (i:RELAYS):
      receiver_recv:
      (2 > t AND t <= 3) AND mode = receiving AND node_event?(cal, i, p, t) AND buffer[i] /= missing -->
        cal' = msg_consume(cal, i, p);
      )
    []
      %----------------------------------------------------------------
      % The majority vote logic is unrolled in the following
      % transitions
      %----------------------------------------------------------------

      receiver_vote_0:
      mode = voting AND ix = 0 AND i_am_atomic?(cal, p, t) -->
        candidate' = missing;
        counter' = 0;
        ix' = ix + 1;
    []
      % Process a normal buffer element
      receiver_vote_loop:
          mode = voting
      AND relay_id(1) <= ix AND ix <= relay_id(num_relays)
      AND i_am_atomic?(cal, p, t)
      AND buffer[ix] /= bad_msg -->

        % Factor the assignments to 'candidate' and 'counter' out of the
        % following psuedocode (based on the ADSL 'iVote' computation):
        %
        % if (buffer[ix] == candidate)
        %   counter += 1;
        % else if (counter == 0) {
        %   candidate = buffer[ix];
        %   counter   = 1;
        % }
        % else
        %   counter -= 1;
        %

        candidate' = IF buffer[ix] = candidate
                       THEN candidate
                     ELSIF counter = 0
                       THEN buffer[ix]
                       ELSE candidate
                     ENDIF;
        counter'   = IF buffer[ix] = candidate
                       THEN counter+1
                     ELSIF counter = 0
                       THEN 1
                       ELSE counter-1
                     ENDIF;

        ix' = ix + 1;
    []
      % Skip over manifestly faulty buffer elements
      receiver_vote_loop_faulty:
          mode = voting
      AND relay_id(1) <= ix AND ix <= relay_id(num_relays)
      AND i_am_atomic?(cal, p, t)
      AND buffer[ix] = bad_msg -->

        ix' = ix + 1;
    []
        receiver_exit:
            mode = voting
        AND ix > relay_id(num_relays)
        AND i_am_atomic?(cal, p, t) -->
          cal' = msg_consume(cal, p, p);  % release the atomic lock
          % If there is a majority in the buffer, than 'candidate' is in the
          % majority.
          vote' = IF candidate = missing
                     THEN error_vote
                  ELSIF candidate = recv_bad_msg  % unwrap error values after vote
                     THEN bad_msg
                  ELSE candidate
                  ENDIF;
          mode' = done;
          receiver_done' = TRUE
    ]
END;


%===----------------------------------------------------------------===
%       System
%===----------------------------------------------------------------===

% asyncronous composition is used to better model message passing
system: MODULE =
        clock
     [] source
     [] (WITH OUTPUT latches:   ARRAY RELAYS OF MESSAGE
         WITH OUTPUT latcheds?: ARRAY RELAYS OF BOOLEAN
           ([] (x:RELAYS):    RENAME latch TO latches[x]
                           IN RENAME latched? TO latcheds?[x]
                           IN relay[x]))
     [] (WITH OUTPUT receivers_done: ARRAY RECEIVERS OF BOOLEAN
         WITH OUTPUT counters:       ARRAY RECEIVERS OF [0..num_relays]
         WITH OUTPUT ixs:            ARRAY RECEIVERS OF IDX
         WITH OUTPUT buffers:        ARRAY RECEIVERS of ARRAY RELAYS of MESSAGE
         WITH OUTPUT votes:          ARRAY RECEIVERS of MESSAGE
         WITH OUTPUT majorities:     ARRAY RECEIVERS of BOOLEAN
         WITH OUTPUT mode:           ARRAY RECEIVERS of RECEIVER_MODES
           ([] (x:RECEIVERS):  RENAME vote TO votes[x]
                               IN RENAME buffer TO buffers[x]
                               IN RENAME receiver_done TO receivers_done[x]
                               IN RENAME counter TO counters[x]
                               IN RENAME ix TO ixs[x]
                               IN RENAME mode TO mode[x]
                               IN receiver[x]));


%===----------------------------------------------------------------===
%       Syncronous Observer
%===----------------------------------------------------------------===

% Alternative to specifying THEOREMs using LTL is the
% synchronous observer for 'validity' and 'agreement'
observer: MODULE =
BEGIN
  INPUT
    source_done: BOOLEAN,
    relays_done: BOOLEAN,
    receivers_done: ARRAY RECEIVERS OF BOOLEAN,
    buffers: ARRAY RECEIVERS OF ARRAY RELAYS OF MESSAGE,
    votes: ARRAY RECEIVERS OF MESSAGE,
    majorities: ARRAY RECEIVERS OF BOOLEAN,
    f: FAULTS
  OUTPUT
    v_ok: BOOLEAN,
    a_ok: BOOLEAN,
    not_done: BOOLEAN
INITIALIZATION
  v_ok = TRUE;
  a_ok = TRUE;
  not_done = TRUE
TRANSITION
  [
    no_validity:
          v_ok
      AND NOT is_faulty?(f[source_id])
      AND (FORALL (x:RECEIVERS): receivers_done[x]
             AND NOT votes[x]=good_msg) -->
        v_ok' = FALSE
  []
    no_agreement:
          a_ok
      AND (FORALL (x:RECEIVERS): receivers_done[x])
      AND (EXISTS (x,y:RECEIVERS):
                 has_majority?(buffers[x])
             AND has_majority?(buffers[y])
             AND votes[x] /= votes[y]) -->
         a_ok' = FALSE
  []
    % For the test THEOREMS below
    all_done:
          not_done
      AND source_done
      AND relays_done
      AND (FORALL (r:RECEIVERS): receivers_done[r]) -->
        not_done' = FALSE
  []
    % prevent deadlock of the observer
    ELSE -->
  ]
END;


ABSTRACT_STATE: TYPE = {a1, a2, a3, a3b, a4, a5, bad};

abstractor: MODULE =
BEGIN
  INPUT
    cal: CALENDAR,
    f: ARRAY IDENTITY OF FAULT_TYPE,
    source_done: BOOLEAN,
    latches: ARRAY RELAYS OF MESSAGE,
    relays_done: BOOLEAN,
    receivers_done: ARRAY RECEIVERS OF BOOLEAN,
    buffers: ARRAY RECEIVERS OF ARRAY RELAYS OF MESSAGE,
    votes: ARRAY RECEIVERS OF MESSAGE
  OUTPUT
    A1, A2, A3, A3b, A4, A5: BOOLEAN
  DEFINITION

    % No messages have been sent or received yet
    A1 =     (FORALL (c: CHANNEL): null?(cal, c))
         AND NOT source_done
         AND NOT relays_done
         AND (FORALL (i: RELAYS):
                latches[i] = missing)
         AND (FORALL (r: RECEIVERS):
                NOT receivers_done[r]
                AND votes[r] = missing
                AND (FORALL (i: RELAYS): buffers[r][i] = missing));

    % source has sent it's message
    A2 =     (FORALL (c: CHANNEL): null?(cal, c) <=> is_receiver_channel?(c))
         AND source_done
         AND NOT relays_done
         AND (FORALL (i: RELAYS):
                latches[i] = missing)
         AND (FORALL (i: RECEIVERS):
                NOT receivers_done[i]
                AND votes[i] = missing)
         AND (FORALL (i: RELAYS, j: RECEIVERS): buffers[j][i] = missing);

    % at least one relay is done; no receivers are done
    % XXX remove fault + latch clauses to external lemma (also A4, A5)
    A3 =     source_done
         AND (FORALL (i: RELAYS): NOT relays_done =>
                    NOT null?(cal, chan(source_id, i))
                AND latches[i] = missing)
         AND (FORALL (i: RELAYS): relays_done =>
                null?(cal, chan(source_id, i))
                AND is_wrapped?(latches[i]))
         AND NOT relays_done
         AND (FORALL (r: RECEIVERS): NOT receivers_done[r]
                AND null?(cal, chan(r,r))
                AND votes[r] = missing)
         AND (FORALL (i: RELAYS, j: RECEIVERS):
                   (    NOT relays_done
                    AND null?(cal, chan(i,j))
                    AND buffers[j][i] = missing)
                OR (    relays_done
                    AND cal.msg[chan(i,j)] = latches[i]
                    AND buffers[j][i] = missing)
                OR (    relays_done
                    AND null?(cal, chan(i,j))
                    AND buffers[j][i] /= missing
                    AND (NOT is_faulty?(f[i]) => buffers[j][i] = latches[i]))
             );

    % all relays are done, but no receivers are done
    A3b =      source_done
          AND (FORALL (i: RELAYS): relays_done
                 AND null?(cal, chan(source_id, i))
                 AND is_wrapped?(latches[i]))
          AND (FORALL (r: RECEIVERS):
                 NOT receivers_done[r]
                 AND votes[r] = missing)
          AND (FORALL (i: RELAYS, j: RECEIVERS):
                    (    cal.msg[chan(i,j)] = latches[i]
                     AND buffers[j][i] = missing)
                 OR (    null?(cal, chan(i,j))
                     AND buffers[j][i] /= missing
                     AND (NOT is_faulty?(f[i]) => buffers[j][i] = latches[i]))
             );

    % all relays are done; at least one receiver is done and one is not done
    A4 =     source_done
         AND (FORALL (i: RELAYS): relays_done
                AND null?(cal, chan(source_id, i))
                AND is_wrapped?(latches[i]))
         AND (EXISTS (r: RECEIVERS): receivers_done[r])
         AND (FORALL (r: RECEIVERS): receivers_done[r] =>
                (   EXISTS (i: RELAYS): votes[r] = unwrap(buffers[r][i])
                 OR votes[r] = error_vote)
                AND (FORALL (i: RELAYS): null?(cal, chan(i,r)))
                AND (FORALL (i: RELAYS):
                       NOT is_faulty?(f[i]) => buffers[r][i] = latches[i])
                AND null?(cal, chan(r,r)))
         AND (EXISTS (r: RECEIVERS): NOT receivers_done[r])
         AND (FORALL (i: RELAYS, j: RECEIVERS):
                   (    cal.msg[chan(i,j)] = latches[i]
                    AND buffers[j][i] = missing)
                OR (    null?(cal, chan(i,j))
                    AND buffers[j][i] /= missing
                    AND (NOT is_faulty?(f[i]) => buffers[j][i] = latches[i]))
             );

    % all nodes are done
    A5 =     source_done
         AND relays_done
         AND (FORALL (i: RELAYS):
                    null?(cal, chan(source_id, i))
                AND is_wrapped?(latches[i]))
         AND (FORALL (r: RECEIVERS): receivers_done[r]
                AND (   EXISTS (i: RELAYS): votes[r] = unwrap(buffers[r][i])
                     OR votes[r] = error_vote)
                AND null?(cal, chan(r,r)))
         AND (FORALL (i: RELAYS, j: RECEIVERS): null?(cal, chan(i,j))
                AND buffers[j][i] /= missing
                AND (NOT is_faulty?(f[i]) => buffers[j][i] = latches[i]));

  TRANSITION
    [ ELSE --> ]

END;


abstract_monitor: MODULE =
BEGIN
  INPUT A1, A2, A3, A3b, A4, A5: BOOLEAN
  LOCAL state: ABSTRACT_STATE
  INITIALIZATION
    state = a1
  TRANSITION
    [
      state = a1 -->
        state' = IF      A1' THEN a1
                   ELSIF A2' THEN a2
                   ELSE           bad
                   ENDIF
    []
      state = a2 -->
        state' = IF      A2' THEN a2
                   ELSIF A3' THEN a3
                   ELSE           bad
                   ENDIF
    []
      state = a3 -->
        state' = IF      A3'  THEN a3
                   ELSIF A3b' THEN a3b
                   ELSE            bad
                   ENDIF
    []
      state = a3b -->
        state' = IF      A3b' THEN a3b
                   ELSIF A4'  THEN a4
                   ELSIF A5'  THEN a5
                   ELSE            bad
                   ENDIF
    []
      state = a4 -->
        state' = IF      A4' THEN a4
                   ELSIF A5' THEN a5
                   ELSE           bad
                   ENDIF
    []
      state = a5 -->
        state' = IF      A5' THEN a5
                   ELSE           bad
                   ENDIF
    []
      % state = bad
      ELSE -->
    ]
END;


system_obs : MODULE = system || observer || abstractor || abstract_monitor;


%===--------------------------------------------------------------===
%       Verification
%===--------------------------------------------------------------===

% Options passed to each 'sal-inf-bmc' invocation by the runproof script
% may be given here. The last 'runproof:' directive will be the one to take
% effect.
%
% for benchmarking -- runproof: --disable-traceability
% runproof: -ice
%

%%%  Abstraction Lemmas

% % sal-inf-bmc  -d 1 om1_tt abstract_init
% abstract_init: LEMMA system_obs |- A1;

% abstract_all - conjunction of all the state predicates
%
% Proved:
% sal-inf-bmc -i -d 1 \
%     -l cal_invt -l receiver_mode_invt \
%     om1_tt abstract_all
%
abstract_all: LEMMA system_obs |-
  G(    (state = a1 => A1)
    AND (state = a2 => A2)
    AND (state = a3 => A3)
    AND (state = a3b => A3b)
    AND (state = a4 => A4)
    AND (state = a5 => A5)
    AND (state /= bad));

%%%  Fault Assumptions

% Helper to compute the number of nodes with a given fault type.
fault_count_go(i: IDENTITY, max: IDENTITY, f: ARRAY IDENTITY OF FAULT_TYPE,
               given: FAULT_TYPE): NATURAL =
  IF i > num_nodes-1 OR i > max
     THEN 0
     ELSE
       LET w:NATURAL = fault_count_go(i+1, max, f, given) IN
       IF f[i] = given
          THEN w+1
          ELSE w
       ENDIF
  ENDIF;

% Compute the number of nodes with a given fault type.
fault_count(f: ARRAY IDENTITY OF FAULT_TYPE, given: FAULT_TYPE): NATURAL =
  fault_count_go(0, num_nodes-1, f, given);

% When a relay or the source is faulty in the symmetric mode, we require that
% the faulty messages sent by them all agree at each point in time.
symmetric_fault_constraint(f: FAULTS): BOOLEAN =
  (f[source_id] = symmetric => FORALL (r0, r1: RELAYS):
     uninterp_msg(source_id, r0) = uninterp_msg(source_id, r1))
  AND
  (FORALL (i: RELAYS):
    f[i] = symmetric => (FORALL (r0, r1: RECEIVERS):
      uninterp_msg(i, r0) = uninterp_msg(i, r1)));

% We only consider faults of the source and relays. A faulty receiver in this
% model is not observable since the receivers don't send any messages.
receiver_fault_constraint(f: FAULTS): BOOLEAN =
  FORALL (r: RECEIVERS): f[r] = nonfaulty;

% Basic fault assumption
%
% This predicate over the fault array enforces our notion of symmetric fault
% and makes the simplifying (but non-essential) assumption that the receivers
% are not faulty.
%
bfa(f: FAULTS): BOOLEAN =
      receiver_fault_constraint(f)
  AND symmetric_fault_constraint(f);

% Maximum fault assumption
%
% In the hybrid fault model we require that the weighted sum of faults is
% strictly less than the number of relays.
%
% The fault model is described more fully in [OMH] Theorem 1 (pg. 7).
mfa(f: FAULTS): BOOLEAN =
      bfa(f)
  AND 2*(fault_count(f, byzantine) + fault_count(f, symmetric)) +
      fault_count(f, manifest) < num_relays
  AND fault_count(f, byzantine) <= 1;

% To test the sharpness of 'mfa', allow at most two faulty nodes.
% Lemmas which don't hold under this mfa include:
%   - (removed!) faults_in_buffer
%   - agreement
%
% mfa(f: FAULTS): BOOLEAN =
%   FORALL (i,j,k: IDENTITY):
%     is_faulty?(f[i]) AND is_faulty?(f[j]) AND is_faulty?(f[k])
%       => (i = j OR j = k OR i = k);


% Validity fault assumption
%
% There is at most 1 faulty node and it is not the source node
%
vfa(f: FAULTS): BOOLEAN =
      mfa(f)
  AND NOT is_faulty?(f[source_id]);


%%%  Basic Invariants

global_time_not_null(t: TIME): BOOLEAN =
  t >= 0 OR t = -2;

valid_cal_times(cal: CALENDAR): BOOLEAN =
  FORALL (c: CHANNEL):
       cal.time[c] = atomic_time
    OR cal.time[c] = invalid_time
    OR cal.time[c] >= 0;

% All event times listed on the calendar are either in the (weak) future, or
% are "atomic times".
monotonic_time(cal: CALENDAR, t: TIME): BOOLEAN =
  FORALL (c: CHANNEL): is_next_time?(cal, cal.time[c]) =>
    cal.time[c] = atomic_time OR cal.time[c] >= t;

% Invariant: a channel is missing a message iff. it lists an the invalid time
missing_cal(cal: CALENDAR): BOOLEAN =
  FORALL (c: CHANNEL): cal.msg[c] = missing <=> cal.time[c] = invalid_time;

% Invariant: there exists at most one event on the calendar with "atomic time"
unique_atomic(cal: CALENDAR): BOOLEAN =
  FORALL (i,j: CHANNEL): cal.time[i] = -2 AND cal.time[j] = -2 => i = j;


% cal_invt - basic invariants of time and the calendar
%
% Proved:
% sal-inf-bmc -i  -d 1 om1_tt.sal cal_invt
%
cal_invt: LEMMA system_obs |-
  G(    monotonic_time(cal, t)
    AND valid_cal_times(cal)
    AND global_time_not_null(t)
    AND missing_cal(cal)
    AND unique_atomic(cal)
   );

% fault_propagation - connect the presence of faulty messages in the calendar
% with the fault status of upstream nodes
%
% Proved:
% sal-inf-bmc -i -d 1 -l cal_invt om1_tt.sal fault_propagation
%
fault_propagation: LEMMA system_obs |-
  G(
    % by construction, no faulty messages are ever stored in source -> relay
    % part of the calendar
    (FORALL (j:RELAYS):
       NOT is_faulty_msg?(cal.msg[chan(source_id, j)]))
    AND (FORALL (i:RECEIVERS, j:RELAYS):
           % faulty msg read into buffer comes from either faulty relay or
           % faulty source
               (is_faulty_msg?(buffers[i][j])
                 => is_faulty?(f[j]) OR is_faulty?(f[source_id]))
           % faulty msg in cal must come from faulty source
           AND (is_faulty_msg?(cal.msg[chan(j, i)])
                 => is_faulty?(f[source_id]))
        )
   );

% Require that latched values either match the intended sent value or else
% match our encoding of bad messages through 'uninterp_msg' depending on the
% fault conditions.
%
% sal-inf-bmc -i -d 1 -l fault_propagation om1_tt.sal source_to_latch
source_to_latch: LEMMA system_obs |-
  G(FORALL (i: RELAYS):
      (NOT latcheds?[i])
    OR
      (    latcheds?[i]
       AND (f[source_id] = nonfaulty => latches[i] = good_msg)
       AND (f[source_id] = byzantine OR f[source_id] = symmetric =>
              latches[i] = wrap(uninterp_msg(source_id, i)))));

% source_to_latch: LEMMA system_obs |-
%   G(FORALL (i: RELAYS): latches[i] = missing OR
%       (    (f[source_id] = nonfaulty => latches[i] = good_msg)
%        AND (f[source_id] = byzantine OR f[source_id] = symmetric =>
%               latches[i] = wrap(uninterp_msg(source_id, i)))));

% manifest_relay - when a relay is manifestly faulty, receivers will only get
% 'bad_msg' from it.
%
% Proved
% sal-inf-bmc -i -d 1 om1_tt manifest_relay
manifest_relay: LEMMA system_obs |-
  G(FORALL (i: RELAYS): f[i] = manifest =>
      FORALL (r: RECEIVERS):
        buffers[r][i] = missing OR buffers[r][i] = bad_msg);

% uninterp_msg_relay - when a relay has a byzantine or symmetric fault, then
% the message it sends to the receiver is uninterpreted (symmetric faults
% are further constrained by the symmetric_fault_constraint).
%
% Proved
% sal-inf-bmc -i -d 1 om1_tt uninterp_msg_relay
uninterp_msg_relay: LEMMA system_obs |-
  G(FORALL (i: RELAYS, j: RECEIVERS):
      (f[i] = byzantine OR f[i] = symmetric) =>
         (   buffers[j][i] = missing
          OR buffers[j][i] = uninterp_msg(i, j))
   );

% manifest_source - when the source is manifestly faulty, relays will only get
% 'bad_msg' from it and they will only store 'recv_bad_msg'.
%
% Proved
% sal-inf-bmc -i -d 1 -l fault_propagation om1_tt manifest_source
manifest_source: LEMMA system_obs |-
  G(
    (f[source_id] = manifest =>
      FORALL (i: RELAYS): NOT latcheds?[i] OR latches[i] = missing OR latches[i] = recv_bad_msg)
    AND
    (EXISTS (i: RELAYS): latches[i] = recv_bad_msg => is_faulty?(f[source_id]) OR NOT latcheds?[i]));

latched_time: LEMMA system_obs |-
  G(FORALL (i: RELAYS): t > 2 => latcheds?[i]);

% missing_buffer_size - for each receiver: # messages currently received +
% # of slots with 'missing' = total number of relays.
%
% Proved:
% sal-inf-bmc -i  -d 1 -l cal_invt om1_tt.sal missing_buffer_size
%
missing_buffer_size: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS, i:RELAYS):
      LET a:IDENTITY = relay_id(1) IN
      LET b:IDENTITY = relay_id(num_relays) IN
        buffer_size[r] +
        cntBuf(a, b, buffers[r], missing) = num_relays);


% receiver_mode_invt - main invarinant of the the receiver mode cycle
%
% Proved:
% sal-inf-bmc -i -d 1 \
%     -l missing_buffer_size \
%     om1_tt.sal receiver_mode_invt
%
receiver_mode_invt: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
    (    NOT receivers_done[r]
             % receiver is receiving messages from relays
     AND (   (    mode[r] = receiving
              AND counters[r] = 0
              AND ixs[r] = 0
              AND buffer_size[r] < num_relays
              AND candidate[r] = missing
             )
             % receiver buffer is full, switched to voting mode
          OR (    mode[r] = voting
              AND counters[r] = 0
              AND ixs[r] = 0
              AND buffer_size[r] = num_relays
              AND candidate[r] = missing
              AND FORALL (i: RELAYS): buffers[r][i] /= missing
             )
             % receiver starts voting by initializing state variables
          OR (    mode[r] = voting
              AND counters[r] <= cntBuf(relay_id(1), ixs[r]-1,
                                        buffers[r], candidate[r])
              AND ixs[r] <= num_relays+1
              AND ixs[r] >= 1
              AND candidate[r] /= bad_msg  % candidate can still be missing here
              AND (   EXISTS (i: RELAYS): (buffers[r][i] = candidate[r] AND i < ixs[r])
                   OR candidate[r] = missing)
              AND buffer_size[r] = num_relays
              AND FORALL (i: RELAYS): buffers[r][i] /= missing
             )
         )
    )
    % receiver has finished voting
    OR (    receivers_done[r]
        AND mode[r] = done
        AND ixs[r] = relay_id(num_relays)+1
        AND (votes[r] = unwrap(candidate[r]) OR votes[r] = error_vote)
        AND buffer_size[r] = num_relays
        AND FORALL (i: RELAYS): buffers[r][i] /= missing
       )
   );


% exists_majority - Additional invariant to 'receiver_mode_invt' that holds
% whenever there is a majority in the voting buffer.
%
% Proved
% sal-inf-bmc -i -d 1 \
%     -l receiver_mode_invt -l majority_vote_invt \
%     om1_tt.sal exists_majority
%
exists_majority: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      mode[r] = done AND has_majority?(buffers[r])
      => m_is_majority(buffers[r], wrap(votes[r]))
   );


% majority_vote_invt -
%
% This is the main invariant of the fast majority vote algorithm MJRTY, see
% [1] Section VI.
%
% In the terminology of [1], I = ixs[r]-1 and K = counters[r], # in support of
% CAND = b.
%
% The value 'a' in the lemma represents the number of evidently 'bad' values
% received. These are skipped during the majority vote and that fact has to be
% taken into account here.
%
% Proved through parameters {6,6}
% sal-inf-bmc -i -d 1 \
%     -l receiver_mode_invt \
%     om1_tt.sal majority_vote_invt
%
majority_vote_invt: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      % a = # of manifestly bad values in the vote buffer so far
      LET a:NATURAL = cntBuf(relay_id(1), ixs[r]-1, buffers[r], bad_msg) IN
      % b = # of delegates so far in support of candidate[r]
      LET b:NATURAL = cntBuf(relay_id(1), ixs[r]-1, buffers[r], candidate[r]) IN
      mode[r] = voting =>
        % 1)
        %   by construction: relay_id(1) <= ixs[r] <= relay_id(num_relays)+1
        % 2)
            (ixs[r] - relay_id(1) > a => candidate[r] /= missing)
        % 3)
        AND 0 <= b - counters[r]
        % 4)
        AND b - counters[r] <= (ixs[r]-relay_id(1)-a-counters[r]) DIV 2
        % 5)
        AND (FORALL (i: RELAYS):
               (buffers[r][i] /= candidate[r] AND buffers[r][i] /= bad_msg) =>
                  cntBuf(relay_id(1), ixs[r]-1, buffers[r], buffers[r][i]) <=
                    (ixs[r]-relay_id(1)-a-counters[r]) DIV 2
            )
  );

% validity -
%
% The system satisfies the validity property under the condition that at most
% one node is faulty and that the source is not faulty.
%
% Proved!
% sal-inf-bmc -i -d 1 \
%     -l exists_majority -l receiver_mode_invt -l abstract_all \
%     -l manifest_relay -l fault_propagation \
%     om1_tt.sal validity
%
validity: THEOREM system_obs |- G(vfa(f) => v_ok);

%===----------------------------------------------------------
%     Agreement
%===----------------------------------------------------------

% agreement -
%
% The system satisfies the agreement property under the condition that at most
% one node is faulty (including, possibly, the source)
%
%
% Proved
% sal-inf-bmc -i -d 1 \
%     -l abstract_all -l cal_invt -l fault_propagation \
%     -l receiver_mode_invt -l majority_vote_invt -l exists_majority \
%     -l manifest_relay -l uninterp_msg_relay -l manifest_source \
%     -l source_to_latch \
%     om1_tt agreement
%
% Stats for num_relays=4, num_recvs=4:
%
%   * 229 s to prove (2.0 Ghz Intel Xeon E312xx)
%   * number of system variables: 129, number of auxiliary variables: 0
%   * Yices file size: 16.6 MB
%
agreement: THEOREM system_obs |- G(mfa(f) => a_ok);



%===--------------------------------------------------------------===
%       Tests
%
% TESTS for bounded model checker; these are non-THEOREMS
%
%===--------------------------------------------------------------===

% counterexample at depth 6
time_test: THEOREM system |- G(t < 2);  % for msg_delay = 1 this implies we
                                        % only advance as far as the relay broadcast

% everyone finishes eventually:
% current counter-example using FINITE model:
% $ sal-inf-bmc -v 1 -d 30 'om1_tt{3,2}' all_done_test
all_done_test: THEOREM system_obs |- G(not_done);

%
% Sanity checks.
%
% If the model is correct, these should all be non-THEOREMS.
% Currently you can find a counter example to 'sanity1' in 'om1_tt{3,3}'
% through bounded model checking to a depth of 25.
%
sanity0: THEOREM system |- G(EXISTS (r: RECEIVERS): NOT receivers_done[r]);
sanity1: THEOREM system |- G(FORALL (r: RECEIVERS): NOT receivers_done[r]);
sanity2: THEOREM system |- G(NOT relays_done);
sanity3: THEOREM system |- G(EXISTS (r: RECEIVERS): EXISTS (i: RELAYS): buffers[r][i] = missing);
sanity4: THEOREM system |- G(EXISTS (r: RECEIVERS): FORALL (i: RELAYS): buffers[r][i] = missing);

%
% Checking for DEADLOCK
%
% If you uncomment the type definitions for the FINITE model near the top
% of the model, you can check for deadlock using the 'sal-deadlock-checker'
% tool. Currently, setting 'upper_bound = 5' and checking 'om1_tt{2,2}' for
% deadlock returns in a reasonable amount of time:
%
% $ sal-deadlock-checker 'om1_tt{2,2}' system

END
